import { z } from 'zod';
import { query } from '../db.js';

export default async function trending(app) {
  app.get('/v1/trending', async (req, reply) => {
    const Q = z.object({
      window: z.string().default('48h'),      // '48h' or '24'
      limit: z.coerce.number().int().min(1).max(100).default(25),
      userId: z.string().uuid().optional()
    });

    const p = Q.safeParse(req.query);
    if (!p.success) return reply.code(400).send({ error: 'Bad Request', issues: p.error.issues });

    const { window, limit, userId } = p.data;

    // parse '48h' => 48
    const { rows: w } = await query('SELECT parse_hours($1) AS hrs', [window]);
    const hrs = w[0].hrs;

    // recompute (cheap) then read
    await query('SELECT refresh_trending_cache($1)', [hrs]);

    let rows;
    if (userId) {
      rows = (await query(`
        WITH base AS (
          SELECT tc.*, u.handle AS creator_handle
          FROM trending_cache tc
          JOIN users u ON u.id = tc.creator_id
          WHERE tc.window_hours = $1
        )
        SELECT
          b.object_type, b.object_id, b.creator_id, b.creator_handle,
          b.title, b.created_at, b.score,
          CASE WHEN f.followee_id IS NOT NULL THEN (b.score * 1.10) ELSE b.score END AS pscore
        FROM base b
        LEFT JOIN follows f
          ON f.follower_id = $2 AND f.followee_id = b.creator_id
        ORDER BY pscore DESC, b.created_at DESC
        LIMIT $3
      `, [hrs, userId, limit])).rows;
    } else {
      rows = (await query(`
        SELECT tc.*, u.handle AS creator_handle
        FROM trending_cache tc
        JOIN users u ON u.id = tc.creator_id
        WHERE tc.window_hours = $1
        ORDER BY tc.score DESC, tc.created_at DESC
        LIMIT $2
      `, [hrs, limit])).rows;
    }

    const items = rows.map(r => ({
      objectType: r.object_type,
      objectId: r.object_id,
      creatorId: r.creator_id,
      creatorHandle: r.creator_handle,
      title: r.title,
      createdAt: r.created_at,
      score: r.pscore ?? r.score
    }));

    return reply.send({ ok: true, windowHours: hrs, items });
  });
}
